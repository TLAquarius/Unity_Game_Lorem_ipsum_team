using UnityEngine; using System.Collections;  [RequireComponent(typeof(Rigidbody2D))] [RequireComponent(typeof(EnemyStats))] public class EnemyRangedAI : EnemyBase // INHERITS FROM ENEMYBASE {     public enum State { Idle, Patrol, Chase, Attack, Hit }     public State currentState;      [Header("Sprite Settings")]     public bool spriteFacesLeft = true; // CHECK THIS if your art faces Left      [Header("References")]     public GameObject bulletPrefab;     public Transform firePoint;     // Where the arrow spawns     public Transform groundCheck;   // At the feet      private Transform player;     private Rigidbody2D rb;     private Animator anim;     private EnemyStats stats;      [Header("Movement")]     public float moveSpeed = 3f;     public float patrolWaitTime = 2f;     public Transform[] patrolPoints;      [Header("Combat Ranges")]     public float detectionRange = 10f; // Far vision     public float shootingRange = 6f;   // Distance to start shooting     public float retreatRange = 3f;    // Run away if player gets this close      [Header("Attack Settings")]     public float fireRate = 2f;     public float attackWindUp = 0.5f; // Time before arrow spawns      [Header("Hurt Settings")]     public float hurtDuration = 0.5f;     public Vector2 selfKnockback = new Vector2(3f, 2f);      private float nextFireTime;     private int patrolIndex;     private bool isProvoked = false;      void Start()     {         rb = GetComponent<Rigidbody2D>();         anim = GetComponent<Animator>();         stats = GetComponent<EnemyStats>();          rb.gravityScale = 1f; // Ensure gravity works          // Subscribe to damage event         if (stats != null) stats.OnTakeDamage += ReactToDamage;          //GameObject p = GameObject.FindGameObjectWithTag("Player");         //if (p != null) player = p.transform;          currentState = State.Patrol;         StartCoroutine(MainLogic());     }      void Update()     {         if (anim != null)         {             bool moving = Mathf.Abs(rb.linearVelocity.x) > 0.1f;             anim.SetBool("isMoving", moving);              // NEW: Play Walk Sound             HandleWalkSound(moving);         }     }      // --- SMART REACTION & HURT LOGIC ---     void ReactToDamage()     {         if (stats.currentHP <= 0) return;          StopAllCoroutines();         StartCoroutine(HurtRoutine());     }      IEnumerator HurtRoutine()     {         PlayHitFeedback();         currentState = State.Hit;          // 1. Visual & Physics         if (anim) anim.SetTrigger("Hurt");          rb.linearVelocity = Vector2.zero; // Stop current move         if (player != null)         {             float dirX = Mathf.Sign(transform.position.x - player.position.x);             rb.AddForce(new Vector2(dirX * selfKnockback.x, selfKnockback.y), ForceMode2D.Impulse);         }          // 2. Stun Time         yield return new WaitForSeconds(hurtDuration);          // 3. Recover         currentState = State.Chase;         isProvoked = true;         StartCoroutine(ResetProvocation());         StartCoroutine(MainLogic());     }      IEnumerator ResetProvocation()     {         yield return new WaitForSeconds(4.0f);         isProvoked = false;     }      // --- MAIN AI LOOP ---     IEnumerator MainLogic()     {         // 1. SAFETY CHECK: Keep trying to find the player if null         while (player == null)         {             GameObject p = GameObject.FindGameObjectWithTag("Player");             if (p != null)             {                 player = p.transform;                 Debug.Log("Enemy found Player!"); // Debug to confirm it works             }             else             {                 // Wait 0.5 seconds before trying again so we don't crash the CPU                 yield return new WaitForSeconds(0.5f);             }         }          // 2. Normal AI Logic (This only runs once Player is found)         while (true)         {             // If player dies or is destroyed mid-game, stop logic safely             if (player == null) yield break;              switch (currentState)             {                 case State.Patrol:                     yield return StartCoroutine(PatrolRoutine());                     break;                 case State.Chase:                     yield return StartCoroutine(ChaseRoutine());                     break;                 case State.Attack:                     yield return StartCoroutine(AttackRoutine());                     break;                 case State.Hit: // Add this to prevent logic overlap during stun                     yield return null;                     break;             }             yield return null;         }     }      IEnumerator PatrolRoutine()     {         if (patrolPoints.Length == 0)         {             // Guard Mode: Just look for player             while (currentState == State.Patrol)             {                 if (Vector2.Distance(transform.position, player.position) < detectionRange)                     currentState = State.Chase;                 yield return null;             }             yield break;         }          Transform target = patrolPoints[patrolIndex];          while (currentState == State.Patrol)         {             if (Vector2.Distance(transform.position, player.position) < detectionRange)             {                 currentState = State.Chase;                 yield break;             }              MoveTowards(target.position, moveSpeed * 0.5f);              if (Vector2.Distance(transform.position, target.position) < 0.5f)             {                 rb.linearVelocity = new Vector2(0, rb.linearVelocity.y); // Stop X, keep Gravity                 yield return new WaitForSeconds(patrolWaitTime);                 patrolIndex = (patrolIndex + 1) % patrolPoints.Length;                 target = patrolPoints[patrolIndex];             }             yield return null;         }     }      IEnumerator ChaseRoutine()     {         while (currentState == State.Chase)         {             float dist = Vector2.Distance(transform.position, player.position);              // 1. Give up if too far AND not provoked             if (!isProvoked && dist > detectionRange * 1.5f)             {                 currentState = State.Patrol;                 yield break;             }              // 2. KITING LOGIC (Run away or Approach)             if (dist < retreatRange)             {                 // TOO CLOSE! Run away if safe                 if (CheckGroundBackwards()) MoveAway(player.position, moveSpeed);                 else                 {                     // Cornered! Switch to attack immediately                     rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);                     currentState = State.Attack;                     yield break;                 }             }             else if (dist > shootingRange)             {                 // TOO FAR! Chase                 if (CheckGroundAhead()) MoveTowards(player.position, moveSpeed);                 else rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);             }             else             {                 // PERFECT RANGE! Stop and Attack                 rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);                 if (Time.time >= nextFireTime)                 {                     currentState = State.Attack;                     yield break;                 }             }              yield return null;         }     }      IEnumerator AttackRoutine()     {         rb.linearVelocity = new Vector2(0, rb.linearVelocity.y); // Brake         FaceTarget(player.position);          if (anim) anim.SetTrigger("Attack");          yield return new WaitForSeconds(attackWindUp);          Shoot(); // Spawn Arrow          float cooldown = 1f / fireRate;         nextFireTime = Time.time + cooldown;          yield return new WaitForSeconds(0.5f); // Recover          currentState = State.Chase;     }      // --- HELPER FUNCTIONS ---      void Shoot()     {         if (bulletPrefab == null || firePoint == null) return;          // Instantiate bullet         GameObject bullet = Instantiate(bulletPrefab, firePoint.position, Quaternion.identity);          // Point bullet at player         Vector2 dir = (player.position - firePoint.position).normalized;         float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;         bullet.transform.rotation = Quaternion.Euler(0, 0, angle);          // NOTE: Bullet movement is handled by the Bullet Script itself (in Start)     }      void MoveTowards(Vector2 target, float speed)     {         float directionX = Mathf.Sign(target.x - transform.position.x);          // FLIP LOGIC (Standardized)         float scaleX = spriteFacesLeft ? -directionX : directionX;         transform.localScale = new Vector3(scaleX, 1, 1);          rb.linearVelocity = new Vector2(directionX * speed, rb.linearVelocity.y);     }      void MoveAway(Vector2 target, float speed)     {         float directionX = Mathf.Sign(transform.position.x - target.x); // Run opposite          // Face Player while running backwards (Kiting)         FaceTarget(target);          rb.linearVelocity = new Vector2(directionX * speed, rb.linearVelocity.y);     }      void FaceTarget(Vector2 target)     {         float directionX = Mathf.Sign(target.x - transform.position.x);         float scaleX = spriteFacesLeft ? -directionX : directionX;         transform.localScale = new Vector3(scaleX, 1, 1);     }      bool CheckGroundAhead()     {         if (groundCheck == null) return true;         // Check slightly in front of facing direction         float facing = Mathf.Sign(transform.localScale.x * (spriteFacesLeft ? -1 : 1));         Vector2 checkPos = (Vector2)groundCheck.position + new Vector2(facing * 0.5f, 0);          return Physics2D.Raycast(checkPos, Vector2.down, 1.5f, LayerMask.GetMask("Ground"));     }      bool CheckGroundBackwards()     {         if (groundCheck == null) return true;         // Check slightly BEHIND facing direction         float facing = Mathf.Sign(transform.localScale.x * (spriteFacesLeft ? -1 : 1));         Vector2 checkPos = (Vector2)groundCheck.position - new Vector2(facing * 0.5f, 0);          return Physics2D.Raycast(checkPos, Vector2.down, 1.5f, LayerMask.GetMask("Ground"));     }      void OnDrawGizmosSelected()     {         Gizmos.color = Color.yellow;         Gizmos.DrawWireSphere(transform.position, detectionRange);         Gizmos.color = Color.red;         Gizmos.DrawWireSphere(transform.position, shootingRange);         Gizmos.color = Color.blue;         Gizmos.DrawWireSphere(transform.position, retreatRange);     } }